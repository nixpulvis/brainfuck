use rand::{thread_rng, Rng};
use super::*;

/// A secure garbled tape used to obscure both it's cell's data, and the
/// access to each cell. This is akin to Oblivious RAM (ORAM).
///
pub struct GarbledTape {
    cells: [u8; 65536],
    cell_key: u8,
    address_keys: [u16; 65536],
    address_index: usize,
}

impl Default for GarbledTape {
    fn default() -> Self {
        // Generate keys.
        //
        // - The key must be random and generated by a non-deterministic,
        // non-repeatable process.  Any key generated by an algorithm will not
        // work. The security of the OTP relies on the randomness of the key.
        // Unfortunately, the randomness of a key cannot be proved.
        //
        // - The key must never be reused. Use of the same key to encrypt
        // different messages, no matter how trivially small, compromises the
        // cipher.
        //
        // - The key must not fall in the hands of the enemy. This may seem
        // obvious, but it points to the weakness of system in that you must be
        // able to transmit large amounts of data to the reader of the pad.
        // Typically, one time pad cipher keys are sent via diplomatic pouch.
        //
        // XXX: We still leak the address_index?
        // XXX: Repeated access patterns are still noticable. We need to change
        //      CBC mode for example: https://www.freesoft.org/CIE/Topics/143.htm
        // keys at each step?
        let mut rng = thread_rng();
        let cell_key = rng.gen();
        let mut address_keys = [0; 65536];
        for k in address_keys.iter_mut() {
            *k = rng.gen();
        }

        GarbledTape {
            // XXX: Clearly not secure putting the key in the default.
            cells: [cell_key; 65536],
            address_keys: address_keys,
            address_index: 0,
            cell_key: cell_key,
        }
    }
}

impl Tape for GarbledTape {
    type Cell = u8;

    fn is_nice() -> bool {
        true
    }

    fn get(&self) -> Self::Cell {
        self.cells[self.address_keys[self.address_index] as usize] ^ self.cell_key
    }

    fn set(&mut self, value: Self::Cell) {
        self.cells[self.address_keys[self.address_index] as usize] = value ^ self.cell_key;
    }

    fn inc_val(&mut self) -> Result<Self::Cell, Error> {
        match self.get().checked_add(1) {
            Some(v) => {
                self.set(v);
                Ok(v)
            },
            None => Err(Error::ValOverflow)
        }
    }

    fn dec_val(&mut self) -> Result<Self::Cell, Error> {
        match self.get().checked_sub(1) {
            Some(v) => {
                self.set(v);
                Ok(v)
            },
            None => Err(Error::ValUnderflow),
        }
    }

    fn inc_ptr(&mut self) -> Result<usize, Error> {
        match self.address_index.checked_add(1) {
            Some(v) => {
                self.address_index = v;
                Ok(v)
            },
            _ => Err(Error::PtrOverflow),
        }
    }

    fn dec_ptr(&mut self) -> Result<usize, Error> {
        match self.address_index.checked_sub(1) {
            Some(v) => {
                self.address_index = v;
                Ok(v)
            },
            _ => Err(Error::PtrUnderflow),
        }
    }

    fn trace(&self) {
        println!("@[[{}] = {}] = {}",
                 self.address_index,
                 self.address_keys[self.address_index],
                 self.cells[self.address_keys[self.address_index] as usize]);
    }
}

tape_tests!(GarbledTape);
